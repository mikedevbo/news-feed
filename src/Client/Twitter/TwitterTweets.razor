@using NewsFeed.Shared.Twitter.Commands
@using static NewsFeed.Shared.Twitter.Commands.StartDownloadingTweets
@implements IDisposable
@inject StateContainer StateContainer
@inject HttpClient Http
@inject TwitterNewsFeedApiClient apiClient
@inject StateContainer StateContainer

@foreach(var item in this.tweets)
{
}

@code
{
    private List<Tweet> tweets = new List<Tweet>();
}

@code
{

    protected override async Task OnInitializedAsync()
    {
        StateContainer.Subscribers += this.Handle;
    }

    public void Dispose()
    {
        StateContainer.Subscribers -= this.Handle;
    }
}

@code {

    private async void Handle(IMessage message)
    {
        switch (message)
        {
            case GroupSelected:
                this.tweets = new List<Tweet>();
                this.StateHasChanged();
                break;

            case UserSelected:
                //var user = (message as UserSelected)!.User;
                //this.tweets = (await this.apiClient.GetTweets(user.Id)).OrderByDescending(t => t.CreatedAt).ToList();
                //this.StateHasChanged();
                break;
            case DownloadTweetsRequested:
                var userTwitterIds = (message as DownloadTweetsRequested)!.twitterUserIds;
                Console.WriteLine(userTwitterIds.Count());
                break;
        }
    }
}

@code
{
    private string StyleFontWeight(Tweet tweet)
    {
        return tweet.IsRead ? "font-weight: normal" : "font-weight: bold";
    }
}

@code
{
    private async Task StartDownloadingTweets(List<UserData> users)
    {
        var result = await this.Http.PostAsJsonAsync<StartDownloadingTweets>(
            $"/twitter/tweets/startdownloading",
            new StartDownloadingTweets(users)
        );

        result.EnsureSuccessStatusCode();
    }
}
