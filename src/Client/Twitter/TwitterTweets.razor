@using NewsFeed.Shared.Twitter.Commands
@using static NewsFeed.Shared.Twitter.Commands.StartDownloadingTweets
@implements IDisposable
@inject StateContainer StateContainer
@inject HttpClient Http
@inject TwitterNewsFeedApiClient apiClient
@inject StateContainer StateContainer

<div class="w3-container">
    <h3>@user.Name</h3>
</div>

<button class="w3-button w3-border w3-margin">Get</button>

@foreach(var tweet in this.tweets)
{
<div class="w3-container w3-panel">
    <div class="w3-card-4 w3-mobile" style="width:50%;">
        <div class="w3-container" style="@IsReadCss(tweet)">
            <p>@tweet.Text</p>
        </div>
        <button class="w3-button w3-border w3-margin" @onclick="e => SetReadState(tweet)">Read</button>
            <button class="w3-button w3-border w3-margin w3-right" style="@IsPersistedCss(tweet)" @onclick="e => SetPersistedState(tweet)">Favorite</button>
    </div>
</div>
}

@code
{
    private (int Id, string Name, string twitterId) user;
    private List<Tweet> tweets = new List<Tweet>();
}

@code
{

    protected override async Task OnInitializedAsync()
    {
        StateContainer.Subscribers += this.Handle;
    }

    public void Dispose()
    {
        StateContainer.Subscribers -= this.Handle;
    }
}

@code {

    private async void Handle(IMessage message)
    {
        switch (message)
        {
            case GroupSelected:
                //this.tweets = new List<Tweet>();
                //this.StateHasChanged();
                break;

            case UserSelected user:
                this.user = (user.Id, user.Name, user.TwitterUserId);
                this.tweets = await this.Http.GetFromJsonAsync<List<Tweet>>($"/twitter/accounts/{this.StateContainer.AccountId}/tweets/{this.user.Id}") ?? new List<Tweet>();
                this.NotifyTweetsLoaded();
                this.StateHasChanged();
                break;
            case DownloadTweetsRequested:
                var userTwitterIds = (message as DownloadTweetsRequested)!.TwitterUserIds;
                Console.WriteLine(userTwitterIds.Count());
                break;
        }
    }
}

@code
{
    private string IsReadCss(Tweet tweet)
    {
        return tweet.IsRead ? "font-weight: normal" : "font-weight: bold";
    }

    private string IsPersistedCss(Tweet tweet)
    {
        return tweet.IsPersisted ? "font-weight: bold" : "font-weight: normal";
    }
}

@code
{
    private async Task SetReadState(Tweet tweet)
    {
        tweet.IsRead = !tweet.IsRead;

        var result = await this.Http.PostAsJsonAsync<SetReadState>(
            $"/twitter/tweets/setReadState",
            new SetReadState(tweet.Id, tweet.IsRead));

        result.EnsureSuccessStatusCode();

        this.NotifyTweetsLoaded();
    }

    private async Task SetPersistedState(Tweet tweet)
    {
        tweet.IsPersisted = !tweet.IsPersisted;

        var result = await this.Http.PostAsJsonAsync<SetFavoriteState>(
            $"/twitter/tweets/setPersistedState",
            new SetFavoriteState(tweet.Id, tweet.IsPersisted));

        result.EnsureSuccessStatusCode();
    }

    private async Task StartDownloadingTweets(List<UserData> users)
    {
        var result = await this.Http.PostAsJsonAsync<StartDownloadingTweets>(
            $"/twitter/tweets/startdownloading",
            new StartDownloadingTweets(users)
        );

        result.EnsureSuccessStatusCode();
    }

    private void NotifyTweetsLoaded()
    {
        this.StateContainer.Publish(new TweetsLoaded(this.user.Id, this.tweets.Count(t => !t.IsRead)));
    }
}
