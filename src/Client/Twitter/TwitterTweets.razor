@using NewsFeed.Shared.Twitter.Commands;
@using static NewsFeed.Shared.Twitter.Commands.StartDownloadingTweets;
@implements IDisposable
@inject StateContainer StateContainer
@inject HttpClient Http
@inject TwitterNewsFeedApiClient apiClient
@inject StateContainer StateContainer

<div class="w3-container">
    <h3>@user.Name</h3>
</div>

<button class="w3-button w3-border w3-margin">Get</button>

@foreach(var tweet in this.tweets)
{
<div class="w3-container w3-panel">
    <div class="w3-card-4 w3-mobile" style="width:50%;">
        <div class="w3-container" style="@IsReadCss(tweet)">
            <p>@tweet.Text</p>
        </div>
        <button class="w3-button w3-border w3-margin" @onclick="e => SetReadState(tweet)">Read</button>
            <button class="w3-button w3-border w3-margin w3-right" style="@IsPersistedCss(tweet)" @onclick="e => SetPersistedState(tweet)">Favorite</button>
    </div>
</div>
}

@*Params*@
@code
{
    private (int Id, string Name, string twitterId) user;
    private List<Tweet> tweets = new List<Tweet>();
}

@*Css*@
@code
{
    private string IsReadCss(Tweet tweet)
    {
        return tweet.IsRead ? "font-weight: normal" : "font-weight: bold";
    }

    private string IsPersistedCss(Tweet tweet)
    {
        return tweet.IsPersisted ? "font-weight: bold" : "font-weight: normal";
    }
}

@*ViewModel*@
@code
{
    public class Tweet
    {
        public int Id { get; set; }

        public int UserId { get; set; }

        public string TweetId { get; set; } = string.Empty;

        public string Text { get; set; } = string.Empty;

        public DateTime? CreatedAt { get; set; }

        public bool IsRead { get; set; }

        public bool IsPersisted { get; set; }
    }

    public async Task<List<Tweet>> Query(GetTweetsRequest request)
    {
        var result = await Extensions.CallApi(Http, request);
        return result.DeserializeXml<List<Tweet>>();
    }
}

@code
{
    protected override async Task OnInitializedAsync()
    {
        StateContainer.Subscribers += this.Handle;
    }

    public void Dispose()
    {
        StateContainer.Subscribers -= this.Handle;
    }
}

@*StateContainer*@
@code {

    private async void Handle(IMessage message)
    {
        switch (message)
        {
            case UserSelected user:
                this.user = (user.Id, user.Name, user.TwitterUserId);
                this.tweets = await this.Query(new GetTweetsRequest(this.user.Id));
                this.NotifyTweetsLoaded();
                this.StateHasChanged();
                break;
            case DownloadTweetsRequested:
                var userTwitterIds = (message as DownloadTweetsRequested)!.TwitterUserIds;
                Console.WriteLine(userTwitterIds.Count());
                break;
        }
    }
}

@*Actions*@
@code
{
    private async Task SetReadState(Tweet tweet)
    {
        tweet.IsRead = !tweet.IsRead;

        await Extensions.CallApi(Http, new SetReadStateRequest(tweet.Id, tweet.IsRead));

        this.NotifyTweetsLoaded();
    }

    private async Task SetPersistedState(Tweet tweet)
    {
        tweet.IsPersisted = !tweet.IsPersisted;

        var result = await this.Http.PostAsJsonAsync<SetFavoriteState>(
            $"/twitter/tweets/setPersistedState",
            new SetFavoriteState(tweet.Id, tweet.IsPersisted));

        result.EnsureSuccessStatusCode();
    }

    private async Task StartDownloadingTweets(List<UserData> users)
    {
        var result = await this.Http.PostAsJsonAsync<StartDownloadingTweets>(
            $"/twitter/tweets/startdownloading",
            new StartDownloadingTweets(users)
        );

        result.EnsureSuccessStatusCode();
    }

    private void NotifyTweetsLoaded()
    {
        this.StateContainer.Publish(new TweetsLoaded(this.user.Id, this.tweets.Count(t => !t.IsRead)));
    }
}
